<!-- Page generated 2021-11-17 12:16:07 +0000-->
<!DOCTYPE html>
<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WL2QLG5');</script>
<title>Deploying Docker containers on ECS | Docker Documentation</title>
  <meta name="description" content="Deploying Docker containers on ECS" />
  <meta name="keywords" content="Docker, AWS, ECS, Integration, context, Compose, cli, deploy, containers, cloud">
  <link rel="canonical" href="https://docs.docker.com/cloud/ecs-integration/" />

  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicons/docs@2x.ico" sizes="129x128">
  <link rel="apple-touch-icon" type="image/x-icon" href="/favicons/docs@2x.ico" sizes="129x128">
  <meta name="msapplication-TileImage" content="/favicons/docs@2x.ico">
  <meta property="og:image" content="/favicons/docs@2x.ico"/>
  <meta name="theme-color" content="#2496ed" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- hide elements that are only shown without JavaScript enabled -->
  <script>document.documentElement.classList.add('js')</script>
  <style>html.js .no-js { display: none !important; }</style><script defer src="/js/theme-switcher.js"></script>
  <script defer src="/js/anchorlinks.js"></script>
  <script defer src="/js/jquery.js"></script>
  <script defer src="/js/bootstrap.min.js"></script>
  <script defer src="/js/docs.js"></script><script defer src="/js/search.js"></script><link rel="preload" as="font" href="https://fonts.gstatic.com/s/opensans/v18/mem8YaGs126MiZpBA-UFVZ0bf8pkAg.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/geomanist/hinted-Geomanist-Book.woff2"    type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/geomanist/hinted-Geomanist-Regular.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/glyphicons-halflings-regular.woff2"       type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/fontawesome-webfont.woff2?v=4.7.0"        type="font/woff2" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/style.css" id="pagestyle">

  <!-- SEO stuff -->
  <meta name="twitter:title" itemprop="title name" content="Deploying Docker containers on ECS"/>
  <meta name="twitter:description" property="og:description" itemprop="description" content="" />
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:domain" content="docs.docker.com"/>
  <meta name="twitter:site" content="@docker_docs"/>
  <meta name="twitter:url" content="https://twitter.com/docker_docs"/>
  <meta name="twitter:image:src" content="https://docs.docker.com/images/docs@2x.png"/>
  <meta name="twitter:image:alt" content="Docker Documentation"/>
  <meta property="og:title" content="Deploying Docker containers on ECS" />
  <meta property="og:description" content="Deploying Docker containers on ECS" />
  <meta property="og:type" content="website"/>
  <meta property="og:updated_time" itemprop="dateUpdated" content="2021-11-17T12:16:07+00:00"/>
  <meta property="og:image" itemprop="image primaryImageOfPage" content="https://docs.docker.com/images/docs@2x.png"/>
  <meta property="og:locale" content="en_US" />
  <meta property="og:url" content="https://docs.docker.com/cloud/ecs-integration/" />
  <meta property="og:site_name" content="Docker Documentation" />
  <meta property="article:published_time" itemprop="datePublished" content="2021-11-17T12:16:07+00:00"/>
  <script type="application/ld+json">{"@context":"http://schema.org","@type":"WebPage","headline":"Deploying Docker containers on ECS","description":"Deploying Docker containers on ECS","url":"https://docs.docker.com/cloud/ecs-integration/"}</script>
  <!-- END SEO STUFF -->
</head>
<body class="colums">
    <header>
        <nav class="nav-secondary navbar navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="/">
                <img class="logo" src="/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs" width="160" height="28" />
            </a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="logo-mobile">
    <a href="/">
        <img src="/images/docker-icon.svg" alt="Docker Docs" title="Docker Docs" width="30" height="30" />
    </a>
</div>
<div class="search-form" id="search-div">
    <form class="search-form form-inline" id="searchForm" action="/search/" method="get">
        <label for="st-search-input" class="sr-only">Search</label>
        <input class="search-field form-control ds-input" id="st-search-input" name="q" placeholder="Search the docs" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteResults"></div>
        <!-- <button type="submit" class="search-submit btn btn-default">Search</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container hidden-sm hidden-xs">
    <div>
        <ul class="nav navbar-nav"><li><a href="/" id="home">Home</a></li><li><a href="/get-started/overview/" id="guides">Guides</a></li><li><a href="/desktop/" id="manuals">Manuals</a></li><li><a href="/reference/" id="reference">Reference</a></li><li><a href="/samples/" id="samples">Samples</a></li></ul>
    </div>
    <div class="ctrl-right">
        <a href="javascript:void(0)" id="menu-toggle" aria-label="Current page's menu toggle"><i class="fa fa-indent" aria-hidden="true"></i></a>
    </div>
</div>
<div class="row hidden-sm hidden-xs">
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li><a href="/" title="Docker docs homepage"><i class="fa fa-home"></i></a></li>
            <li><a href="/get-started/overview/">Guides</a></li><li><a href="/cloud/aci-integration/">Deploy your app to the cloud</a></li><li><a href="/cloud/ecs-integration/">Docker and ECS</a></li></ol>
    </nav>
</div></div>
    </div>
</nav>

    </header>
    <div class="wrapper right-open">
        <div class="container-fluid">
            <div class="row">
                <div class="col-body">
                    <main class="col-content content">
                        <section class="section"><h1>Deploying Docker containers on ECS</h1><p><em class="reading-time">Estimated reading time: 21 minutes</em></p><h2 id="overview">Overview</h2>

<p>The Docker Compose CLI enables developers to use native Docker commands to run applications in Amazon EC2 Container Service (ECS) when building cloud-native applications.</p>

<p>The integration between Docker and Amazon ECS allows developers to use the Docker Compose CLI to:</p>

<ul>
  <li>Set up an AWS context in one Docker command, allowing you to switch from a local context to a cloud context and run applications quickly and easily</li>
  <li>Simplify multi-container application development on Amazon ECS using Compose files</li>
</ul>

<p>Also see the <a href="/cloud/ecs-architecture/">ECS integration architecture</a>, <a href="/cloud/ecs-compose-features/">full list of compose features</a> and <a href="/cloud/ecs-compose-examples/">Compose examples for ECS integration</a>.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>To deploy Docker containers on ECS, you must meet the following requirements:</p>

<ol>
  <li>
    <p>Download and install the latest version of Docker Desktop.</p>

    <ul>
      <li><a href="/desktop/mac/install/">Download for Mac</a></li>
      <li><a href="/desktop/windows/install/">Download for Windows</a></li>
    </ul>

    <p>Alternatively, install the <a href="#install-the-docker-compose-cli-on-linux">Docker Compose CLI for Linux</a>.</p>
  </li>
  <li>
    <p>Ensure you have an AWS account.</p>
  </li>
</ol>

<p>Docker not only runs multi-container applications locally, but also enables
developers to seamlessly deploy Docker containers on Amazon ECS using a
Compose file with the <code class="highlighter-rouge">docker compose up</code> command. The following sections
contain instructions on how to deploy your Compose application on Amazon ECS.</p>

<h2 id="run-an-application-on-ecs">Run an application on ECS</h2>

<h3 id="requirements">Requirements</h3>

<p>AWS uses a fine-grained permission model, with specific role for each resource type and operation.</p>

<p>To ensure that Docker ECS integration is allowed to manage resources for your Compose application, you have to ensure your AWS credentials <a href="https://aws.amazon.com/iam/features/manage-permissions/">grant access to following AWS IAM permissions</a>:</p>

<ul>
  <li>application-autoscaling:*</li>
  <li>cloudformation:*</li>
  <li>ec2:AuthorizeSecurityGroupIngress</li>
  <li>ec2:CreateSecurityGroup</li>
  <li>ec2:CreateTags</li>
  <li>ec2:DeleteSecurityGroup</li>
  <li>ec2:DescribeRouteTables</li>
  <li>ec2:DescribeSecurityGroups</li>
  <li>ec2:DescribeSubnets</li>
  <li>ec2:DescribeVpcs</li>
  <li>ec2:RevokeSecurityGroupIngress</li>
  <li>ecs:CreateCluster</li>
  <li>ecs:CreateService</li>
  <li>ecs:DeleteCluster</li>
  <li>ecs:DeleteService</li>
  <li>ecs:DeregisterTaskDefinition</li>
  <li>ecs:DescribeClusters</li>
  <li>ecs:DescribeServices</li>
  <li>ecs:DescribeTasks</li>
  <li>ecs:ListAccountSettings</li>
  <li>ecs:ListTasks</li>
  <li>ecs:RegisterTaskDefinition</li>
  <li>ecs:UpdateService</li>
  <li>elasticloadbalancing:*</li>
  <li>iam:AttachRolePolicy</li>
  <li>iam:CreateRole</li>
  <li>iam:DeleteRole</li>
  <li>iam:DetachRolePolicy</li>
  <li>iam:PassRole</li>
  <li>logs:CreateLogGroup</li>
  <li>logs:DeleteLogGroup</li>
  <li>logs:DescribeLogGroups</li>
  <li>logs:FilterLogEvents</li>
  <li>route53:CreateHostedZone</li>
  <li>route53:DeleteHostedZone</li>
  <li>route53:GetHealthCheck</li>
  <li>route53:GetHostedZone</li>
  <li>route53:ListHostedZonesByName</li>
  <li>servicediscovery:*</li>
</ul>

<p>GPU support, which relies on EC2 instances to run containers with attached GPU devices,
require a few additional permissions:</p>

<ul>
  <li>ec2:DescribeVpcs</li>
  <li>autoscaling:*</li>
  <li>iam:CreateInstanceProfile</li>
  <li>iam:AddRoleToInstanceProfile</li>
  <li>iam:RemoveRoleFromInstanceProfile</li>
  <li>iam:DeleteInstanceProfile</li>
</ul>

<h3 id="create-aws-context">Create AWS context</h3>

<p>Run the <code class="highlighter-rouge">docker context create ecs myecscontext</code> command to create an Amazon ECS Docker
context named <code class="highlighter-rouge">myecscontext</code>. If you have already installed and configured the AWS CLI,
the setup command lets you select an existing AWS profile to connect to Amazon.
Otherwise, you can create a new profile by passing an
<a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys" target="_blank" rel="noopener" class="_">AWS access key ID and a secret access key</a>.
Finally, you can configure your ECS context to retrieve AWS credentials by <code class="highlighter-rouge">AWS_*</code> environment variables, which is a common way to integrate with
third-party tools and single-sign-on providers.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">? Create a Docker context using:  [Use arrows to move, type to filter]
  An existing AWS profile
  AWS secret and token credentials
</span><span class="gp">&gt;</span> AWS environment variables
</code></pre></div></div>

<p>After you have created an AWS context, you can list your Docker contexts by running the <code class="highlighter-rouge">docker context ls</code> command:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">NAME                TYPE                DESCRIPTION                               DOCKER ENDPOINT               KUBERNETES ENDPOINT   ORCHESTRATOR
myecscontext        ecs                 credentials read from environment
default *           moby                Current DOCKER_HOST based configuration   unix:///var/run/docker.sock                         swarm
</span></code></pre></div></div>

<h3 id="run-a-compose-application">Run a Compose application</h3>

<p>You can deploy and manage multi-container applications defined in Compose files
to Amazon ECS using the <code class="highlighter-rouge">docker compose</code> command. To do this:</p>

<ul>
  <li>
    <p>Ensure you are using your ECS context. You can do this either by specifying
the <code class="highlighter-rouge">--context myecscontext</code> flag with your command, or by setting the
current context using the command <code class="highlighter-rouge">docker context use myecscontext</code>.</p>
  </li>
  <li>
    <p>Run <code class="highlighter-rouge">docker compose up</code> and <code class="highlighter-rouge">docker compose down</code> to start and then
stop a full Compose application.</p>

    <p>By default, <code class="highlighter-rouge">docker compose up</code> uses the <code class="highlighter-rouge">compose.yaml</code> or <code class="highlighter-rouge">docker-compose.yaml</code> file in
the current folder. You can specify the working directory using the --workdir flag or
specify the Compose file directly using <code class="highlighter-rouge">docker compose --file mycomposefile.yaml up</code>.</p>

    <p>You can also specify a name for the Compose application using the <code class="highlighter-rouge">--project-name</code> flag during deployment. If no name is specified, a name will be derived from the working directory.</p>
  </li>
</ul>

<p>Docker ECS integration converts the Compose application model into a set of AWS resources, described as a <a href="https://aws.amazon.com/cloudformation/" target="_blank" rel="noopener" class="_">CloudFormation</a> template. The actual mapping is described in <a href="https://github.com/docker/compose-cli/blob/main/docs/ecs-architecture.md" target="_blank" rel="noopener" class="_">technical documentation</a>.
You can review the generated template using <code class="highlighter-rouge">docker compose convert</code> command, and follow CloudFormation applying this model within
<a href="https://console.aws.amazon.com/cloudformation/home" target="_blank" rel="noopener" class="_">AWS web console</a> when you run <code class="highlighter-rouge">docker compose up</code>, in addition to CloudFormation events being displayed
in your terminal.</p>

<ul>
  <li>
    <p>You can view services created for the Compose application on Amazon ECS and
their state using the <code class="highlighter-rouge">docker compose ps</code> command.</p>
  </li>
  <li>
    <p>You can view logs from containers that are part of the Compose application
using the <code class="highlighter-rouge">docker compose logs</code> command.</p>
  </li>
</ul>

<p>Also see the <a href="/cloud/ecs-compose-features/">full list of compose features</a>.</p>

<h2 id="rolling-update">Rolling update</h2>

<p>To update your application without interrupting production flow you can simply
use <code class="highlighter-rouge">docker compose up</code> on the updated Compose project.
Your ECS services are created with rolling update configuration. As you run
<code class="highlighter-rouge">docker compose up</code> with a modified Compose file, the stack will be
updated to reflect changes, and if required, some services will be replaced.
This replacement process will follow the rolling-update configuration set by
your services <a href="/compose/compose-file/compose-file-v3/#update_config"><code class="highlighter-rouge">deploy.update_config</code></a>
configuration.</p>

<p>AWS ECS uses a percent-based model to define the number of containers to be
run or shut down during a rolling update. The Docker Compose CLI computes
rolling update configuration according to the <code class="highlighter-rouge">parallelism</code> and <code class="highlighter-rouge">replicas</code>
fields. However, you might prefer to directly configure a rolling update
using the extension fields <code class="highlighter-rouge">x-aws-min_percent</code> and <code class="highlighter-rouge">x-aws-max_percent</code>.
The former sets the minimum percent of containers to run for service, and the
latter sets the maximum percent of additional containers to start before
previous versions are removed.</p>

<p>By default, the ECS rolling update is set to run twice the number of
containers for a service (200%), and has the ability to shut down 100%
containers during the update.</p>

<h2 id="view-application-logs">View application logs</h2>

<p>The Docker Compose CLI configures AWS CloudWatch Logs service for your
containers.
By default you can see logs of your compose application the same way you check logs of local deployments:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">#</span> fetch logs <span class="k">for </span>application <span class="k">in </span>current working directory
<span class="gp">$</span> docker compose logs
<span class="go">
</span><span class="gp">#</span> specify compose project name
<span class="gp">$</span> docker compose <span class="nt">--project-name</span> PROJECT logs
<span class="go">
</span><span class="gp">#</span> specify compose file
<span class="gp">$</span> docker compose <span class="nt">--file</span> /path/to/docker-compose.yaml logs
</code></pre></div></div>

<p>A log group is created for the application as <code class="highlighter-rouge">docker-compose/&lt;application_name&gt;</code>,
and log streams are created for each service and container in your application
as <code class="highlighter-rouge">&lt;application_name&gt;/&lt;service_name&gt;/&lt;container_ID&gt;</code>.</p>

<p>You can fine tune AWS CloudWatch Logs using extension field <code class="highlighter-rouge">x-aws-logs_retention</code>
in your Compose file to set the number of retention days for log events. The
default behavior is to keep logs forever.</p>

<p>You can also pass <code class="highlighter-rouge">awslogs</code>
parameters to your container as standard
Compose file <code class="highlighter-rouge">logging.driver_opts</code> elements. See <a href="https://docs.amazonaws.cn/en_us/AmazonECS/latest/developerguide/using_awslogs.html" target="_blank" rel="noopener" class="_">AWS documentation</a> for details on available log driver options.</p>

<h2 id="private-docker-images">Private Docker images</h2>

<p>The Docker Compose CLI automatically configures authorization so you can pull private images from the Amazon ECR registry on the same AWS account. To pull private images from another registry, including Docker Hub, you’ll have to create a Username + Password (or a Username + Token) secret on the <a href="https://docs.aws.amazon.com/secretsmanager/" target="_blank" rel="noopener" class="_">AWS Secrets Manager service</a>.</p>

<p>For your convenience, the Docker Compose CLI offers the <code class="highlighter-rouge">docker secret</code> command, so you can manage secrets created on AWS SMS without having to install the AWS CLI.</p>

<p>First, create a <code class="highlighter-rouge">token.json</code> file to define your DockerHub username and access token.</p>

<p>For instructions on how to generate access tokens, see <a href="/docker-hub/access-tokens/">Managing access tokens</a>.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"username"</span><span class="p">:</span><span class="s2">"DockerHubUserName"</span><span class="p">,</span><span class="w">
  </span><span class="s2">"password"</span><span class="p">:</span><span class="s2">"DockerHubAccessToken"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>You can then create a secret from this file using <code class="highlighter-rouge">docker secret</code>:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker secret create dockerhubAccessToken token.json
<span class="go">arn:aws:secretsmanager:eu-west-3:12345:secret:DockerHubAccessToken
</span></code></pre></div></div>

<p>Once created, you can use this ARN in you Compose file using using <code class="highlighter-rouge">x-aws-pull_credentials</code> custom extension with the Docker image URI for your service.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">worker</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">mycompany/privateimage</span>
    <span class="na">x-aws-pull_credentials</span><span class="pi">:</span> <span class="s2">"</span><span class="s">arn:aws:secretsmanager:eu-west-3:12345:secret:DockerHubAccessToken"</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Note</strong></p>

  <p>If you set the Compose file version to 3.8 or later, you can use the same Compose file for local deployment using <code class="highlighter-rouge">docker-compose</code>. Custom ECS extensions will be ignored in this case.</p>
</blockquote>

<h2 id="service-discovery">Service discovery</h2>

<p>Service-to-service communication is implemented transparently by default, so you can deploy your Compose applications with multiple interconnected services without changing the compose file between local and ECS deployment. Individual services can run with distinct constraints (memory, cpu) and replication rules.</p>

<h3 id="service-names">Service names</h3>

<p>Services are registered automatically by the Docker Compose CLI on <a href="https://docs.aws.amazon.com/cloud-map/latest/dg/what-is-cloud-map.html" target="_blank" rel="noopener" class="_">AWS Cloud Map</a> during application deployment. They are declared as fully qualified domain names of the form: <code class="highlighter-rouge">&lt;service&gt;.&lt;compose_project_name&gt;.local</code>.</p>

<p>Services can retrieve their dependencies using Compose service names (as they do when deploying locally with docker-compose), or optionally use the fully qualified names.</p>

<h3 id="dependent-service-startup-time-and-dns-resolution">Dependent service startup time and DNS resolution</h3>

<p>Services get concurrently scheduled on ECS when a Compose file is deployed. AWS Cloud Map introduces an initial delay for DNS service to be able to resolve your services domain names. Your code needs to support this delay by waiting for dependent services to be ready, or by adding a wait-script as the entrypoint to your Docker image, as documented in <a href="/compose/startup-order/">Control startup order</a>.
Note this need to wait for dependent services in your Compose application also exists when deploying locally with docker-compose, but the delay is typically shorter. Issues might become more visible when deploying to ECS if services do not wait for their dependencies to be available.</p>

<p>Alternatively, you can use the <a href="https://github.com/compose-spec/compose-spec/blob/master/spec.md#depends_on" target="_blank" rel="noopener" class="_">depends_on</a> feature of the Compose file format. By doing this, dependent service will be created first, and application deployment will wait for it to be up and running before starting the creation of the dependent services.</p>

<h3 id="service-isolation">Service isolation</h3>

<p>Service isolation is implemented by the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-security-groups.html" target="_blank" rel="noopener" class="_">Security Groups</a> rules, allowing services sharing a common Compose file “network” to communicate together using their Compose service names.</p>

<h2 id="volumes">Volumes</h2>

<p>ECS integration supports volume management based on Amazon Elastic File System (Amazon EFS).
For a Compose file to declare a <code class="highlighter-rouge">volume</code>, ECS integration will define creation of an EFS
file system within the CloudFormation template, with <code class="highlighter-rouge">Retain</code> policy so data won’t
be deleted on application shut-down. If the same application (same project name) is
deployed again, the file system will be re-attached to offer the same user experience
developers are used to with docker-compose.</p>

<p>A basic compose service using a volume can be declared like this:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">mydata:/some/container/path</span>
<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">mydata</span><span class="pi">:</span>
</code></pre></div></div>

<p>With no specific volume options, the volume still must be declared in the <code class="highlighter-rouge">volumes</code>section for
the compose file to be valid (in the above example the empty <code class="highlighter-rouge">mydata:</code> entry)
If required, the initial file system can be customized using <code class="highlighter-rouge">driver-opts</code>:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">volumes</span><span class="pi">:</span>
  <span class="na">my-data</span><span class="pi">:</span>
    <span class="na">driver_opts</span><span class="pi">:</span>
      <span class="c1"># Filesystem configuration</span>
      <span class="na">backup_policy</span><span class="pi">:</span> <span class="s">ENABLED</span>
      <span class="na">lifecycle_policy</span><span class="pi">:</span> <span class="s">AFTER_14_DAYS</span>
      <span class="na">performance_mode</span><span class="pi">:</span> <span class="s">maxIO</span>
      <span class="na">throughput_mode</span><span class="pi">:</span> <span class="s">provisioned</span>
      <span class="na">provisioned_throughput</span><span class="pi">:</span> <span class="s">1</span>
</code></pre></div></div>

<p>File systems created by executing <code class="highlighter-rouge">docker compose up</code> on AWS can be listed using
<code class="highlighter-rouge">docker volume ls</code> and removed with <code class="highlighter-rouge">docker volume rm &lt;filesystemID&gt;</code>.</p>

<p>An existing file system can also be used for users who already have data stored on EFS
or want to use a file system created by another Compose stack.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">volumes</span><span class="pi">:</span>
  <span class="na">my-data</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">fs-123abcd</span>
</code></pre></div></div>

<p>Accessing a volume from a container can introduce POSIX user ID
permission issues, as Docker images can define arbitrary user ID / group ID for the
process to run inside a container. However, the same <code class="highlighter-rouge">uid:gid</code> will have to match
POSIX permissions on the file system. To work around the possible conflict, you can set the volume
<code class="highlighter-rouge">uid</code> and <code class="highlighter-rouge">gid</code> to be used when accessing a volume:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">volumes</span><span class="pi">:</span>
  <span class="na">my-data</span><span class="pi">:</span>
    <span class="na">driver_opts</span><span class="pi">:</span>
      <span class="c1"># Access point configuration</span>
      <span class="na">uid</span><span class="pi">:</span> <span class="s">0</span>
      <span class="na">gid</span><span class="pi">:</span> <span class="s">0</span>
</code></pre></div></div>

<h2 id="secrets">Secrets</h2>

<p>You can pass secrets to your ECS services using Docker model to bind sensitive
data as files under <code class="highlighter-rouge">/run/secrets</code>. If your Compose file declares a secret as
file, such a secret will be created as part of your application deployment on
ECS. If you use an existing secret as <code class="highlighter-rouge">external: true</code> reference in your
Compose file, use the ECS Secrets Manager full ARN as the secret name:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">webapp</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">...</span>
    <span class="na">secrets</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">foo</span>

<span class="na">secrets</span><span class="pi">:</span>
  <span class="na">foo</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">arn:aws:secretsmanager:eu-west-3:1234:secret:foo-ABC123"</span>
    <span class="na">external</span><span class="pi">:</span> <span class="no">true</span>
</code></pre></div></div>

<p>Secrets will be available at runtime for your service as a plain text file <code class="highlighter-rouge">/run/secrets/foo</code>.</p>

<p>The AWS Secrets Manager allows you to store sensitive data either as a plain
text (like Docker secret does), or as a hierarchical JSON document. You can
use the latter with Docker Compose CLI by using custom field <code class="highlighter-rouge">x-aws-keys</code> to
define which entries in the JSON document to bind as a secret in your service
container.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">webapp</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">...</span>
    <span class="na">secrets</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">foo</span>

<span class="na">secrets</span><span class="pi">:</span>
  <span class="na">foo</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">arn:aws:secretsmanager:eu-west-3:1234:secret:foo-ABC123"</span>
    <span class="na">keys</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">bar"</span>
</code></pre></div></div>

<p>By doing this, the secret for <code class="highlighter-rouge">bar</code> key will be available at runtime for your
service as a plain text file <code class="highlighter-rouge">/run/secrets/foo/bar</code>. You can use the special
value <code class="highlighter-rouge">*</code> to get all keys bound in your container.</p>

<h2 id="auto-scaling">Auto scaling</h2>

<p>Scaling service static information (non auto-scaling) can be specified using the normal Compose syntax:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">foo</span><span class="pi">:</span>
    <span class="na">deploy</span><span class="pi">:</span>
      <span class="na">replicas</span><span class="pi">:</span> <span class="s">3</span>
</code></pre></div></div>

<p>The Compose file model does not define any attributes to declare auto-scaling conditions.
Therefore, we rely on <code class="highlighter-rouge">x-aws-autoscaling</code> custom extension to define the auto-scaling range, as
well as cpu <em>or</em> memory to define target metric, expressed as resource usage percent.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">foo</span><span class="pi">:</span>
    <span class="na">deploy</span><span class="pi">:</span>
      <span class="na">x-aws-autoscaling</span><span class="pi">:</span>
        <span class="na">min</span><span class="pi">:</span> <span class="s">1</span>
        <span class="na">max</span><span class="pi">:</span> <span class="s">10</span> <span class="c1">#required</span>
        <span class="na">cpu</span><span class="pi">:</span> <span class="s">75</span>
        <span class="c1"># mem: - mutualy exlusive with cpu</span>
</code></pre></div></div>

<h2 id="iam-roles">IAM roles</h2>

<p>Your ECS Tasks are executed with a dedicated IAM role, granting access
to AWS Managed policies<a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_execution_IAM_role.html"><code class="highlighter-rouge">AmazonECSTaskExecutionRolePolicy</code></a>
and <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecr_managed_policies.html"><code class="highlighter-rouge">AmazonEC2ContainerRegistryReadOnly</code></a>.
In addition, if your service uses secrets, IAM Role gets additional
permissions to read and decrypt secrets from the AWS Secret Manager.</p>

<p>You can grant additional managed policies to your service execution
by using <code class="highlighter-rouge">x-aws-policies</code> inside a service definition:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">foo</span><span class="pi">:</span>
    <span class="na">x-aws-policies</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">arn:aws:iam::aws:policy/AmazonS3FullAccess"</span>
</code></pre></div></div>

<p>You can also write your own <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html">IAM Policy Document</a>
to fine tune the IAM role to be applied to your ECS service, and use
<code class="highlighter-rouge">x-aws-role</code> inside a service definition to pass the
yaml-formatted policy document.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">foo</span><span class="pi">:</span>
    <span class="na">x-aws-role</span><span class="pi">:</span>
      <span class="na">Version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">2012-10-17"</span>
      <span class="na">Statement</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">Effect</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Allow"</span>
          <span class="na">Action</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s2">"</span><span class="s">some_aws_service"</span>
          <span class="na">Resource</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="s2">"</span><span class="s">*"</span>
</code></pre></div></div>

<h2 id="tuning-the-cloudformation-template">Tuning the CloudFormation template</h2>

<p>The Docker Compose CLI relies on <a href="https://docs.aws.amazon.com/cloudformation/" target="_blank" rel="noopener" class="_">Amazon CloudFormation</a> to manage the application deployment. To get more control on the created resources, you can use <code class="highlighter-rouge">docker compose convert</code> to generate a CloudFormation stack file from your Compose file. This allows you to inspect resources it defines, or customize the template for your needs, and then apply the template to AWS using the AWS CLI, or the AWS web console.</p>

<p>Once you have identified the changes required to your CloudFormation template, you can include <em>overlays</em> in your
Compose file that will be automatically applied on <code class="highlighter-rouge">compose up</code>. An <em>overlay</em> is a yaml object that uses the same CloudFormation template data structure as the one generated by ECS integration, but only contains attributes to
be updated or added. It will be merged with the generated template before being applied on the AWS infrastructure.</p>

<h3 id="adjusting-load-balancer-http-healthcheck-configuration">Adjusting Load Balancer http HealthCheck configuration</h3>

<p>While ECS cluster uses the <code class="highlighter-rouge">HealthCheck</code> command on container to get service health, Application Load Balancers define
their own URL-based HealthCheck mechanism so traffic gets routed. As the Compose model does not offer such an
abstraction (yet), the default one is applied, which queries your service under <code class="highlighter-rouge">/</code> expecting HTTP status code
<code class="highlighter-rouge">200</code>.</p>

<p>You can tweak this behavior using a cloudformation overlay by following the <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html" target="_blank" rel="noopener" class="_">AWS CloudFormation User Guide</a> for
configuration reference:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">webapp</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">acme/webapp</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>

<span class="na">x-aws-cloudformation</span><span class="pi">:</span>
  <span class="na">Resources</span><span class="pi">:</span>
    <span class="na">WebappTCP80TargetGroup</span><span class="pi">:</span>
      <span class="na">Properties</span><span class="pi">:</span>
        <span class="na">HealthCheckPath</span><span class="pi">:</span> <span class="s">/health</span>
        <span class="na">Matcher</span><span class="pi">:</span>
          <span class="na">HttpCode</span><span class="pi">:</span> <span class="s">200-499</span>
</code></pre></div></div>

<h3 id="setting-ssl-termination-by-load-balancer">Setting SSL termination by Load Balancer</h3>

<p>You can use Application Load Balancer to handle the SSL termination for HTTPS services, so that your code, which ran inside
a container, doesn’t have to. This is currently not supported by the ECS integration due to the lack of an equivalent abstraction in the Compose specification. However, you can rely on overlays to enable this feature on generated Listeners configuration:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">webapp</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">acme/webapp</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>

<span class="na">x-aws-cloudformation</span><span class="pi">:</span>
  <span class="na">Resources</span><span class="pi">:</span>
    <span class="na">WebappTCP80Listener</span><span class="pi">:</span>
      <span class="na">Properties</span><span class="pi">:</span>
        <span class="na">Certificates</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">CertificateArn</span><span class="pi">:</span> <span class="s2">"</span><span class="s">arn:aws:acm:certificate/123abc"</span>
        <span class="na">Protocol</span><span class="pi">:</span> <span class="s">HTTPS</span>
</code></pre></div></div>

<h2 id="using-existing-aws-network-resources">Using existing AWS network resources</h2>

<p>By default, the Docker Compose CLI creates an ECS cluster for your Compose application, a Security Group per network in your Compose file on your AWS account’s default VPC, and a LoadBalancer to route traffic to your services.</p>

<p>With the following basic compose file, the Docker Compose CLI will automatically create these ECS constructs including the load balancer to route traffic to the exposed port 80.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
</code></pre></div></div>

<p>If your AWS account does not have <a href="https://github.com/docker/ecs-plugin/blob/master/docs/requirements.md#permissions" target="_blank" rel="noopener" class="_">permissions</a> to create such resources, or if you want to manage these yourself, you can use the following custom Compose extensions:</p>

<ul>
  <li>
    <p>Use <code class="highlighter-rouge">x-aws-cluster</code> as a top-level element in your Compose file to set the ID
of an ECS cluster when deploying a Compose application. Otherwise, a
cluster will be created for the Compose project.</p>
  </li>
  <li>
    <p>Use <code class="highlighter-rouge">x-aws-vpc</code> as a top-level element in your Compose file to set the ARN
of a VPC when deploying a Compose application.</p>
  </li>
  <li>
    <p>Use <code class="highlighter-rouge">x-aws-loadbalancer</code> as a top-level element in your Compose file to set
the ARN of an existing LoadBalancer.</p>
  </li>
</ul>

<p>The latter can be used for those who want to customize application exposure, typically to
use an existing domain name for your application:</p>

<ol>
  <li>
    <p>Use the AWS web console or CLI to get your VPC and Subnets IDs. You can retrieve the default VPC ID and attached subnets using this AWS CLI commands:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ```console
 $ aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId'
    
 "vpc-123456"
 $ aws ec2 describe-subnets --filters Name=vpc-id,Values=vpc-123456 --query 'Subnets[*].SubnetId'
    
 [
     "subnet-1234abcd",
     "subnet-6789ef00",
 ]
 ```
</code></pre></div>    </div>
  </li>
  <li>
    <p>Use the AWS CLI to create your load balancer. The AWS Web Console can also be used but will require adding at least one listener, which we don’t need here.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ```console
 $ aws elbv2 create-load-balancer --name myloadbalancer --type application --subnets "subnet-1234abcd" "subnet-6789ef00"
    
 {
     "LoadBalancers": [
         {
             "IpAddressType": "ipv4",
             "VpcId": "vpc-123456",
             "LoadBalancerArn": "arn:aws:elasticloadbalancing:us-east-1:1234567890:loadbalancer/app/myloadbalancer/123abcd456",
             "DNSName": "myloadbalancer-123456.us-east-1.elb.amazonaws.com",
 &lt;...&gt;
 ```
</code></pre></div>    </div>
  </li>
  <li>
    <p>To assign your application an existing domain name, you can configure your DNS with a
CNAME entry pointing to just-created loadbalancer’s <code class="highlighter-rouge">DNSName</code> reported as you created the loadbalancer.</p>
  </li>
  <li>
    <p>Use Loadbalancer ARN to set <code class="highlighter-rouge">x-aws-loadbalancer</code> in your compose file, and deploy your application using <code class="highlighter-rouge">docker compose up</code> command.</p>
  </li>
</ol>

<p>Please note Docker ECS integration won’t be aware of this domain name, so <code class="highlighter-rouge">docker compose ps</code> command will report URLs with loadbalancer DNSName, not your own domain.</p>

<p>You also can use <code class="highlighter-rouge">external: true</code> inside a network definition in your Compose file for
Docker Compose CLI to <em>not</em> create a Security Group, and set <code class="highlighter-rouge">name</code> with the
ID of an existing SecurityGroup you want to use for network connectivity between
services:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">networks</span><span class="pi">:</span>
  <span class="na">back_tier</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s2">"</span><span class="s">sg-1234acbd"</span>
</code></pre></div></div>

<h2 id="local-simulation">Local simulation</h2>

<p>When you deploy your application on ECS, you may also rely on the additional AWS services.
In such cases, your code must embed the AWS SDK and retrieve API credentials at runtime.
AWS offers a credentials discovery mechanism which is fully implemented by the SDK, and relies
on accessing a metadata service on a fixed IP address.</p>

<p>Once you adopt this approach, running your application locally for testing or debug purposes
can be difficult. Therefore, we have introduced an option on context creation to set the
<code class="highlighter-rouge">ecs-local</code> context to maintain application portability between local workstation and the
AWS cloud provider.</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker context create ecs <span class="nt">--local-simulation</span> ecsLocal
<span class="go">Successfully created ecs-local context "ecsLocal"
</span></code></pre></div></div>

<p>When you select a local simulation context, running the <code class="highlighter-rouge">docker compose up</code> command doesn’t
deploy your application on ECS. Therefore, you must run it locally, automatically adjusting your Compose
application so it includes the <a href="https://github.com/awslabs/amazon-ecs-local-container-endpoints/">ECS local endpoints</a>.
This allows the AWS SDK used by application code to
access a local mock container as “AWS metadata API” and retrieve credentials from your own
local <code class="highlighter-rouge">.aws/credentials</code> config file.</p>

<h2 id="install-the-docker-compose-cli-on-linux">Install the Docker Compose CLI on Linux</h2>

<p>The Docker Compose CLI adds support for running and managing containers on ECS.</p>

<h3 id="install-prerequisites">Install Prerequisites</h3>

<p><a href="/get-docker/">Docker 19.03 or later</a></p>

<h3 id="install-script">Install script</h3>

<p>You can install the new CLI using the install script:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> curl <span class="nt">-L</span> https://raw.githubusercontent.com/docker/compose-cli/main/scripts/install/install_linux.sh | sh
</code></pre></div></div>

<h2 id="faq">FAQ</h2>

<p><strong>What does the error <code class="highlighter-rouge">this tool requires the "new ARN resource ID format"</code> mean?</strong></p>

<p>This error message means that your account requires the new ARN resource ID format for ECS. To learn more, see <a href="https://aws.amazon.com/blogs/compute/migrating-your-amazon-ecs-deployment-to-the-new-arn-and-resource-id-format-2/" target="_blank" rel="noopener" class="_">Migrating your Amazon ECS deployment to the new ARN and resource ID format</a>.</p>

<h2 id="feedback">Feedback</h2>

<p>Thank you for trying out the Docker Compose CLI. Your feedback is very important to us. Let us know your feedback by creating an issue in the <a href="https://github.com/docker/compose-cli" target="_blank" rel="noopener" class="_">Compose CLI</a> GitHub repository.</p>
<span class="glyphicon glyphicon-tags" style="padding-right: 10px"></span><span style="vertical-align: 2px"><a href="/search/?q=Docker">Docker</a>, <a href="/search/?q=AWS">AWS</a>, <a href="/search/?q=ECS">ECS</a>, <a href="/search/?q=Integration">Integration</a>, <a href="/search/?q=context">context</a>, <a href="/search/?q=Compose">Compose</a>, <a href="/search/?q=cli">cli</a>, <a href="/search/?q=deploy">deploy</a>, <a href="/search/?q=containers">containers</a>, <a href="/search/?q=cloud">cloud</a></span><div class="ratings-div"><div id="pd_rating_holder_8453675"></div></div></section>
                    </main>
                    <nav class="col-nav">
                        <div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
                            <div id="navbar" class="nav-sidebar">
                                <ul class="nav hidden-md hidden-lg"></ul>
                                <ul class="nav" id="jsTOCLeftNav"></ul>
                            </div>
                        </div>
                    </nav>
                    <div class="col-toc">
                        <div class="sidebar hidden-xs hidden-sm">
                            <div class="toc-nav">
                                <div class="feedback-links">
                                    <ul><li><a href="https://github.com/docker/docker.github.io/edit/master/cloud/ecs-integration.md"><i class="fa fa-pencil-square-o" aria-hidden="true"></i> Edit this page</a></li><li><a href="https://github.com/docker/docker.github.io/issues/new?body=File: [cloud/ecs-integration.md](https://docs.docker.com/cloud/ecs-integration/)" class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> Request docs changes</a></li>
                                        <li><div class="toggle-mode">
  <div class="icon">
      <i class="fa fa-sun-o" aria-hidden="true"></i>
  </div>
  <div class="toggle-switch">
      <label class="switch">
          <input type="checkbox" id="switch-style">
          <span class="slider round"></span>
      </label>
  </div>
  <div class="icon">
      <i class="fa fa-moon-o" aria-hidden="true"></i>
  </div>
</div>
</li>
                                    </ul>
                                </div><div id="side-toc-title">On this page:</div>
<ul id="my_toc" class="inline_toc">
  <li><a href="#overview" class="nomunge">Overview</a>
    <ul>
      <li><a href="#prerequisites" class="nomunge">Prerequisites</a></li>
      <li><a href="#run-an-application-on-ecs" class="nomunge">Run an application on ECS</a></li>
      <li><a href="#rolling-update" class="nomunge">Rolling update</a></li>
      <li><a href="#view-application-logs" class="nomunge">View application logs</a></li>
      <li><a href="#private-docker-images" class="nomunge">Private Docker images</a></li>
      <li><a href="#service-discovery" class="nomunge">Service discovery</a></li>
      <li><a href="#volumes" class="nomunge">Volumes</a></li>
      <li><a href="#secrets" class="nomunge">Secrets</a></li>
      <li><a href="#auto-scaling" class="nomunge">Auto scaling</a></li>
      <li><a href="#iam-roles" class="nomunge">IAM roles</a></li>
      <li><a href="#tuning-the-cloudformation-template" class="nomunge">Tuning the CloudFormation template</a></li>
      <li><a href="#using-existing-aws-network-resources" class="nomunge">Using existing AWS network resources</a></li>
      <li><a href="#local-simulation" class="nomunge">Local simulation</a></li>
      <li><a href="#install-the-docker-compose-cli-on-linux" class="nomunge">Install the Docker Compose CLI on Linux</a></li>
      <li><a href="#faq" class="nomunge">FAQ</a></li>
      <li><a href="#feedback" class="nomunge">Feedback</a></li>
    </ul>
  </li>
</ul>

</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
          
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/why-docker">Why Docker?</a></b></li>
                        <li><a href="https://www.docker.com/what-container">What is a Container?</a></li>
                        <li><a href="https://docker.events.cube365.net/dockercon/">DockerCon</a></li>
                        <li><b><a href="https://www.docker.com/products/overview">Products</a></b></li>
                        <li><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></li>
                        <li><a href="https://www.docker.com/products/docker-hub">Docker Hub</a></li>
                        <li><a href="https://www.docker.com/roadmap">Docker Product Roadmap</a></li>
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Features</a></b></li>
                        <li><a href="https://www.docker.com/products/container-runtime">Container Runtime</a></li>
                        <li><a href="https://www.docker.com/products/developer-tools">Developer Tools</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Developers</a></b></li>
                        <li><a href="https://www.docker.com/use-cases">Use Cases</a></li>
                        <li><a href="https://www.docker.com/docker-community">Community</a></li>
                        <li><a href="https://www.docker.com/open-source">Open Source</a></li>
                        <li><a href="https://www.docker.com/community/docker-captains">Docker Captains</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Pricing</a></b></li>
                        <li><a href="https://www.docker.com/pricing/faq">FAQs</a></li>
                        <li><a href="https://www.docker.com/partners/programs">Docker Verified Publisher Program</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/company" target="_blank" rel="noopener">Company</a></b></li>
                        <li><a href="https://www.docker.com/company">About Us</a></li>
                        <li><a href="https://www.docker.com/blog/" target="_blank" rel="noopener">Blog</a></li>
                        <li><a href="https://www.docker.com/customers">Customers</a></li>
                        <li><a href="https://www.docker.com/partners">Partners</a></li>
                        <li><a href="https://www.docker.com/company/newsroom">Newsroom</a></li>
                        <li><a href="https://www.docker.com/careers">Careers</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact Us</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="http://status.docker.com/">Status</a></li>
                        <li><a href="https://www.docker.com/legal">Legal</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2013-2021 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="http://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="http://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-slideshare"><a href="https://www.slideshare.net/docker">Slideshare</a></li>
                    <li class="fa fa-reddit"><a href="https://www.reddit.com/r/docker">Reddit</a></li>
                </ul>
            </div>
        </div>
    </div>

    </footer>
    <script>const pageURL = "/cloud/ecs-integration/";</script><script>
    let PDRTJS_settings_8453675 = {
        "id": "8453675",
        "unique_id": "cloud/ecs-integration.md",
        "title": "Deploying Docker containers on ECS",
        "font_family": "Open Sans, sans serif",
        "font_color": "b9c2cc",
        "font_align": "center",
        "permalink": "https://github.com/docker/docker.github.io/blob/master/cloud/ecs-integration.md"
    };
    (function (d, c, j) {
        if (!document.getElementById(j)) {
            let pd=d.createElement(c),s;pd.id=j;pd.src='https://polldaddy.com/js/rating/rating.js';s=document.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd, s);
        }
    }(document, 'script', 'pd-rating-js'));
</script></body>
</html>

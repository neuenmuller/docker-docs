<!-- Page generated 2021-11-17 12:16:07 +0000-->
<!DOCTYPE html>
<html lang="en"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WL2QLG5');</script>
<title>Runtime metrics | Docker Documentation</title>
  <meta name="description" content="Measure the behavior of running containers" />
  <meta name="keywords" content="docker, metrics, CPU, memory, disk, IO, run, runtime, stats">
  <link rel="canonical" href="https://docs.docker.com/config/containers/runmetrics/" />

  <!-- favicon -->
  <link rel="icon" type="image/x-icon" href="/favicons/docs@2x.ico" sizes="129x128">
  <link rel="apple-touch-icon" type="image/x-icon" href="/favicons/docs@2x.ico" sizes="129x128">
  <meta name="msapplication-TileImage" content="/favicons/docs@2x.ico">
  <meta property="og:image" content="/favicons/docs@2x.ico"/>
  <meta name="theme-color" content="#2496ed" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- hide elements that are only shown without JavaScript enabled -->
  <script>document.documentElement.classList.add('js')</script>
  <style>html.js .no-js { display: none !important; }</style><script defer src="/js/theme-switcher.js"></script>
  <script defer src="/js/anchorlinks.js"></script>
  <script defer src="/js/jquery.js"></script>
  <script defer src="/js/bootstrap.min.js"></script>
  <script defer src="/js/docs.js"></script><script defer src="/js/search.js"></script><link rel="preload" as="font" href="https://fonts.gstatic.com/s/opensans/v18/mem8YaGs126MiZpBA-UFVZ0bf8pkAg.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/geomanist/hinted-Geomanist-Book.woff2"    type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/geomanist/hinted-Geomanist-Regular.woff2" type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/glyphicons-halflings-regular.woff2"       type="font/woff2" crossorigin="anonymous">
  <link rel="preload" as="font" href="/fonts/fontawesome-webfont.woff2?v=4.7.0"        type="font/woff2" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/font-awesome.min.css">
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <link rel="stylesheet" href="/css/style.css" id="pagestyle">

  <!-- SEO stuff -->
  <meta name="twitter:title" itemprop="title name" content="Runtime metrics"/>
  <meta name="twitter:description" property="og:description" itemprop="description" content="" />
  <meta name="twitter:card" content="summary_large_image"/>
  <meta name="twitter:domain" content="docs.docker.com"/>
  <meta name="twitter:site" content="@docker_docs"/>
  <meta name="twitter:url" content="https://twitter.com/docker_docs"/>
  <meta name="twitter:image:src" content="https://docs.docker.com/images/docs@2x.png"/>
  <meta name="twitter:image:alt" content="Docker Documentation"/>
  <meta property="og:title" content="Runtime metrics" />
  <meta property="og:description" content="Measure the behavior of running containers" />
  <meta property="og:type" content="website"/>
  <meta property="og:updated_time" itemprop="dateUpdated" content="2021-11-17T12:16:07+00:00"/>
  <meta property="og:image" itemprop="image primaryImageOfPage" content="https://docs.docker.com/images/docs@2x.png"/>
  <meta property="og:locale" content="en_US" />
  <meta property="og:url" content="https://docs.docker.com/config/containers/runmetrics/" />
  <meta property="og:site_name" content="Docker Documentation" />
  <meta property="article:published_time" itemprop="datePublished" content="2021-11-17T12:16:07+00:00"/>
  <script type="application/ld+json">{"@context":"http://schema.org","@type":"WebPage","headline":"Runtime metrics","description":"Measure the behavior of running containers","url":"https://docs.docker.com/config/containers/runmetrics/"}</script>
  <!-- END SEO STUFF -->
</head>
<body class="colums">
    <header>
        <nav class="nav-secondary navbar navbar-fixed-top">
    <div class="container-fluid">
        <div class="navbar-header">
            <a href="/">
                <img class="logo" src="/images/docker-docs-logo.svg" alt="Docker Docs" title="Docker Docs" width="160" height="28" />
            </a>
        </div>
        <div class="navbar-collapse" aria-expanded="false" style="height: 1px;">
            <div class="logo-mobile">
    <a href="/">
        <img src="/images/docker-icon.svg" alt="Docker Docs" title="Docker Docs" width="30" height="30" />
    </a>
</div>
<div class="search-form" id="search-div">
    <form class="search-form form-inline" id="searchForm" action="/search/" method="get">
        <label for="st-search-input" class="sr-only">Search</label>
        <input class="search-field form-control ds-input" id="st-search-input" name="q" placeholder="Search the docs" type="search" autocomplete="off" spellcheck="false" dir="auto" style="position: relative; vertical-align: top;">
        <div id="autocompleteResults"></div>
        <!-- <button type="submit" class="search-submit btn btn-default">Search</button> -->
    </form>
</div>
<div class="sidebar-toggle">
    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
    </button>
</div>
<div class="nav-container hidden-sm hidden-xs">
    <div>
        <ul class="nav navbar-nav"><li><a href="/" id="home">Home</a></li><li><a href="/get-started/overview/" id="guides">Guides</a></li><li><a href="/desktop/" id="manuals">Manuals</a></li><li><a href="/reference/" id="reference">Reference</a></li><li><a href="/samples/" id="samples">Samples</a></li></ul>
    </div>
    <div class="ctrl-right">
        <a href="javascript:void(0)" id="menu-toggle" aria-label="Current page's menu toggle"><i class="fa fa-indent" aria-hidden="true"></i></a>
    </div>
</div>
<div class="row hidden-sm hidden-xs">
    <nav aria-label="breadcrumb">
        <ol class="breadcrumb">
            <li><a href="/" title="Docker docs homepage"><i class="fa fa-home"></i></a></li>
            <li><a href="/get-started/overview/">Guides</a></li><li><a>Run your app in production</a></li><li><a href="/config/containers/start-containers-automatically/">Configure containers</a></li><li><a href="/config/containers/runmetrics/">Container runtime metrics</a></li></ol>
    </nav>
</div></div>
    </div>
</nav>

    </header>
    <div class="wrapper right-open">
        <div class="container-fluid">
            <div class="row">
                <div class="col-body">
                    <main class="col-content content">
                        <section class="section"><h1>Runtime metrics</h1><p><em class="reading-time">Estimated reading time: 19 minutes</em></p><h2 id="docker-stats">Docker stats</h2>

<p>You can use the <code class="highlighter-rouge">docker stats</code> command to live stream a container’s
runtime metrics. The command supports CPU, memory usage, memory limit,
and network IO metrics.</p>

<p>The following is a sample output from the <code class="highlighter-rouge">docker stats</code> command</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> docker stats redis1 redis2
<span class="go">
CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O
redis1              0.07%               796 KB / 64 MB        1.21%               788 B / 648 B       3.568 MB / 512 KB
redis2              0.07%               2.746 MB / 64 MB      4.29%               1.266 KB / 648 B    12.4 MB / 0 B
</span></code></pre></div></div>

<p>The <a href="/engine/reference/commandline/stats/">docker stats</a> reference page has
more details about the <code class="highlighter-rouge">docker stats</code> command.</p>

<h2 id="control-groups">Control groups</h2>

<p>Linux Containers rely on <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt">control groups</a>
which not only track groups of processes, but also expose metrics about
CPU, memory, and block I/O usage. You can access those metrics and
obtain network usage metrics as well. This is relevant for “pure” LXC
containers, as well as for Docker containers.</p>

<p>Control groups are exposed through a pseudo-filesystem. In recent
distros, you should find this filesystem under <code class="highlighter-rouge">/sys/fs/cgroup</code>. Under
that directory, you see multiple sub-directories, called devices,
freezer, blkio, etc.; each sub-directory actually corresponds to a different
cgroup hierarchy.</p>

<p>On older systems, the control groups might be mounted on <code class="highlighter-rouge">/cgroup</code>, without
distinct hierarchies. In that case, instead of seeing the sub-directories,
you see a bunch of files in that directory, and possibly some directories
corresponding to existing containers.</p>

<p>To figure out where your control groups are mounted, you can run:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> <span class="nb">grep </span>cgroup /proc/mounts
</code></pre></div></div>

<h3 id="enumerate-cgroups">Enumerate cgroups</h3>

<p>The file layout of cgroups is significantly different between v1 and v2.</p>

<p>If <code class="highlighter-rouge">/sys/fs/cgroup/cgroup.controllers</code> is present on your system, you are using v2,
otherwise you are using v1.
Refer to the subsection that corresponds to your cgroup version.</p>

<blockquote>
  <p><strong>Note</strong></p>

  <p>As of 2020, Fedora is the only well-known Linux distributon that uses cgroup v2 by default.
Fedora uses cgroup v2 by default since Fedora 31.</p>
</blockquote>

<h4 id="cgroup-v1">cgroup v1</h4>
<p>You can look into <code class="highlighter-rouge">/proc/cgroups</code> to see the different control group subsystems
known to the system, the hierarchy they belong to, and how many groups they contain.</p>

<p>You can also look at <code class="highlighter-rouge">/proc/&lt;pid&gt;/cgroup</code> to see which control groups a process
belongs to. The control group is shown as a path relative to the root of
the hierarchy mountpoint. <code class="highlighter-rouge">/</code> means the process has not been assigned to a
group, while <code class="highlighter-rouge">/lxc/pumpkin</code> indicates that the process is a member of a
container named <code class="highlighter-rouge">pumpkin</code>.</p>

<h4 id="cgroup-v2">cgroup v2</h4>

<p>On cgroup v2 hosts, the content of <code class="highlighter-rouge">/proc/cgroups</code> isn’t meaningful.
See <code class="highlighter-rouge">/sys/fs/cgroup/cgroup.controllers</code> to the available controllers.</p>

<h3 id="changing-cgroup-version">Changing cgroup version</h3>

<p>Changing cgroup version requires rebooting the entire system.</p>

<p>On systemd-based systems, cgroup v2 can be enabled by adding <code class="highlighter-rouge">systemd.unified_cgroup_hierarchy=1</code>
to the kernel cmdline.
To revert the cgroup version to v1, you need to set <code class="highlighter-rouge">systemd.unified_cgroup_hierarchy=0</code> instead.</p>

<p>If <code class="highlighter-rouge">grubby</code> command is available on your system (e.g. on Fedora), the cmdline can be modified as follows:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> <span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>ALL <span class="nt">--args</span><span class="o">=</span><span class="s2">"systemd.unified_cgroup_hierarchy=1"</span>
</code></pre></div></div>

<p>If <code class="highlighter-rouge">grubby</code> command is not available, edit the <code class="highlighter-rouge">GRUB_CMDLINE_LINUX</code> line in <code class="highlighter-rouge">/etc/default/grub</code>
and run <code class="highlighter-rouge">sudo update-grub</code>.</p>

<h3 id="running-docker-on-cgroup-v2">Running Docker on cgroup v2</h3>

<p>Docker supports cgroup v2 since Docker 20.10.
Running Docker on cgroup v2 also requires the following conditions to be satisfied:</p>
<ul>
  <li>containerd: v1.4 or later</li>
  <li>runc: v1.0.0-rc91 or later</li>
  <li>Kernel: v4.15 or later (v5.2 or later is recommended)</li>
</ul>

<p>Note that the cgroup v2 mode behaves slightly different from the cgroup v1 mode:</p>
<ul>
  <li>The default cgroup driver (<code class="highlighter-rouge">dockerd --exec-opt native.cgroupdriver</code>) is “systemd” on v2, “cgroupfs” on v1.</li>
  <li>The default cgroup namespace mode (<code class="highlighter-rouge">docker run --cgroupns</code>) is “private” on v2, “host” on v1.</li>
  <li>The <code class="highlighter-rouge">docker run</code> flags <code class="highlighter-rouge">--oom-kill-disable</code> and <code class="highlighter-rouge">--kernel-memory</code> are discarded on v2.</li>
</ul>

<h3 id="find-the-cgroup-for-a-given-container">Find the cgroup for a given container</h3>

<p>For each container, one cgroup is created in each hierarchy. On
older systems with older versions of the LXC userland tools, the name of
the cgroup is the name of the container. With more recent versions
of the LXC tools, the cgroup is <code class="highlighter-rouge">lxc/&lt;container_name&gt;.</code></p>

<p>For Docker containers using cgroups, the container name is the full
ID or long ID of the container. If a container shows up as ae836c95b4c3
in <code class="highlighter-rouge">docker ps</code>, its long ID might be something like
<code class="highlighter-rouge">ae836c95b4c3c9e9179e0e91015512da89fdec91612f63cebae57df9a5444c79</code>. You can
look it up with <code class="highlighter-rouge">docker inspect</code> or <code class="highlighter-rouge">docker ps --no-trunc</code>.</p>

<p>Putting everything together to look at the memory metrics for a Docker
container, take a look at the following paths:</p>
<ul>
  <li><code class="highlighter-rouge">/sys/fs/cgroup/memory/docker/&lt;longid&gt;/</code> on cgroup v1, <code class="highlighter-rouge">cgroupfs</code> driver</li>
  <li><code class="highlighter-rouge">/sys/fs/cgroup/memory/system.slice/docker-&lt;longid&gt;.scope/</code> on cgroup v1, <code class="highlighter-rouge">systemd</code> driver</li>
  <li><code class="highlighter-rouge">/sys/fs/cgroup/docker/&lt;longid/&gt;</code> on cgroup v2, <code class="highlighter-rouge">cgroupfs</code> driver</li>
  <li><code class="highlighter-rouge">/sys/fs/cgroup/system.slice/docker-&lt;longid&gt;.scope/</code> on cgroup v2, <code class="highlighter-rouge">systemd</code> driver</li>
</ul>

<h3 id="metrics-from-cgroups-memory-cpu-block-io">Metrics from cgroups: memory, CPU, block I/O</h3>

<blockquote>
  <p><strong>Note</strong></p>

  <p>This section is not yet updated for cgroup v2.
For further information about cgroup v2, refer to <a href="https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html">the kernel documentation</a>.</p>
</blockquote>

<p>For each subsystem (memory, CPU, and block I/O), one or
more pseudo-files exist and contain statistics.</p>

<h4 id="memory-metrics-memorystat">Memory metrics: <code class="highlighter-rouge">memory.stat</code></h4>

<p>Memory metrics are found in the “memory” cgroup. The memory
control group adds a little overhead, because it does very fine-grained
accounting of the memory usage on your host. Therefore, many distros
chose to not enable it by default. Generally, to enable it, all you have
to do is to add some kernel command-line parameters:
<code class="highlighter-rouge">cgroup_enable=memory swapaccount=1</code>.</p>

<p>The metrics are in the pseudo-file <code class="highlighter-rouge">memory.stat</code>.
Here is what it looks like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cache 11492564992
rss 1930993664
mapped_file 306728960
pgpgin 406632648
pgpgout 403355412
swap 0
pgfault 728281223
pgmajfault 1724
inactive_anon 46608384
active_anon 1884520448
inactive_file 7003344896
active_file 4489052160
unevictable 32768
hierarchical_memory_limit 9223372036854775807
hierarchical_memsw_limit 9223372036854775807
total_cache 11492564992
total_rss 1930993664
total_mapped_file 306728960
total_pgpgin 406632648
total_pgpgout 403355412
total_swap 0
total_pgfault 728281223
total_pgmajfault 1724
total_inactive_anon 46608384
total_active_anon 1884520448
total_inactive_file 7003344896
total_active_file 4489052160
total_unevictable 32768
</code></pre></div></div>

<p>The first half (without the <code class="highlighter-rouge">total_</code> prefix) contains statistics relevant
to the processes within the cgroup, excluding sub-cgroups. The second half
(with the <code class="highlighter-rouge">total_</code> prefix) includes sub-cgroups as well.</p>

<p>Some metrics are “gauges”, or values that can increase or decrease. For instance,
<code class="highlighter-rouge">swap</code> is the amount of swap space used by the members of the cgroup.
Some others are “counters”, or values that can only go up, because
they represent occurrences of a specific event. For instance, <code class="highlighter-rouge">pgfault</code>
indicates the number of page faults since the creation of the cgroup.</p>

<style>table tr > td:first-child { white-space: nowrap;}</style>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>cache</strong></td>
      <td>The amount of memory used by the processes of this control group that can be associated precisely with a block on a block device. When you read from and write to files on disk, this amount increases. This is the case if you use “conventional” I/O (<code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code> syscalls) as well as mapped files (with <code class="highlighter-rouge">mmap</code>). It also accounts for the memory used by <code class="highlighter-rouge">tmpfs</code> mounts, though the reasons are unclear.</td>
    </tr>
    <tr>
      <td><strong>rss</strong></td>
      <td>The amount of memory that <em>doesn’t</em> correspond to anything on disk: stacks, heaps, and anonymous memory maps.</td>
    </tr>
    <tr>
      <td><strong>mapped_file</strong></td>
      <td>Indicates the amount of memory mapped by the processes in the control group. It doesn’t give you information about <em>how much</em> memory is used; it rather tells you <em>how</em> it is used.</td>
    </tr>
    <tr>
      <td><strong>pgfault</strong>, <strong>pgmajfault</strong></td>
      <td>Indicate the number of times that a process of the cgroup triggered a “page fault” and a “major fault”, respectively. A page fault happens when a process accesses a part of its virtual memory space which is nonexistent or protected. The former can happen if the process is buggy and tries to access an invalid address (it is sent a <code class="highlighter-rouge">SIGSEGV</code> signal, typically killing it with the famous <code class="highlighter-rouge">Segmentation fault</code> message). The latter can happen when the process reads from a memory zone which has been swapped out, or which corresponds to a mapped file: in that case, the kernel loads the page from disk, and let the CPU complete the memory access. It can also happen when the process writes to a copy-on-write memory zone: likewise, the kernel preempts the process, duplicate the memory page, and resume the write operation on the process’s own copy of the page. “Major” faults happen when the kernel actually needs to read the data from disk. When it just  duplicates an existing page, or allocate an empty page, it’s a regular (or “minor”) fault.</td>
    </tr>
    <tr>
      <td><strong>swap</strong></td>
      <td>The amount of swap currently used by the processes in this cgroup.</td>
    </tr>
    <tr>
      <td><strong>active_anon</strong>, <strong>inactive_anon</strong></td>
      <td>The amount of <em>anonymous</em> memory that has been identified has respectively <em>active</em> and <em>inactive</em> by the kernel. “Anonymous” memory is the memory that is <em>not</em> linked to disk pages. In other words, that’s the equivalent of the rss counter described above. In fact, the very definition of the rss counter is <strong>active_anon</strong> + <strong>inactive_anon</strong> - <strong>tmpfs</strong> (where tmpfs is the amount of memory used up by <code class="highlighter-rouge">tmpfs</code> filesystems mounted by this control group). Now, what’s the difference between “active” and “inactive”? Pages are initially “active”; and at regular intervals, the kernel sweeps over the memory, and tags some pages as “inactive”. Whenever they are accessed again, they are immediately retagged “active”. When the kernel is almost out of memory, and time comes to swap out to disk, the kernel swaps “inactive” pages.</td>
    </tr>
    <tr>
      <td><strong>active_file</strong>, <strong>inactive_file</strong></td>
      <td>Cache memory, with <em>active</em> and <em>inactive</em> similar to the <em>anon</em> memory above. The exact formula is <strong>cache</strong> = <strong>active_file</strong> + <strong>inactive_file</strong> + <strong>tmpfs</strong>. The exact rules used by the kernel to move memory pages between active and inactive sets are different from the ones used for anonymous memory, but the general principle is the same. When the kernel needs to reclaim memory, it is cheaper to reclaim a clean (=non modified) page from this pool, since it can be reclaimed immediately (while anonymous pages and dirty/modified pages need to be written to disk first).</td>
    </tr>
    <tr>
      <td><strong>unevictable</strong></td>
      <td>The amount of memory that cannot be reclaimed; generally, it accounts for memory that has been “locked” with <code class="highlighter-rouge">mlock</code>. It is often used by crypto frameworks to make sure that secret keys and other sensitive material never gets swapped out to disk.</td>
    </tr>
    <tr>
      <td><strong>memory_limit</strong>, <strong>memsw_limit</strong></td>
      <td>These are not really metrics, but a reminder of the limits applied to this cgroup. The first one indicates the maximum amount of physical memory that can be used by the processes of this control group; the second one indicates the maximum amount of RAM+swap.</td>
    </tr>
  </tbody>
</table>

<p>Accounting for memory in the page cache is very complex. If two
processes in different control groups both read the same file
(ultimately relying on the same blocks on disk), the corresponding
memory charge is split between the control groups. It’s nice, but
it also means that when a cgroup is terminated, it could increase the
memory usage of another cgroup, because they are not splitting the cost
anymore for those memory pages.</p>

<h3 id="cpu-metrics-cpuacctstat">CPU metrics: <code class="highlighter-rouge">cpuacct.stat</code></h3>

<p>Now that we’ve covered memory metrics, everything else is
simple in comparison. CPU metrics are in the
<code class="highlighter-rouge">cpuacct</code> controller.</p>

<p>For each container, a pseudo-file <code class="highlighter-rouge">cpuacct.stat</code> contains the CPU usage
accumulated by the processes of the container, broken down into <code class="highlighter-rouge">user</code> and
<code class="highlighter-rouge">system</code> time. The distinction is:</p>

<ul>
  <li><code class="highlighter-rouge">user</code> time is the amount of time a process has direct control of the CPU,
executing process code.</li>
  <li><code class="highlighter-rouge">system</code> time is the time the kernel is executing system calls on behalf of
the process.</li>
</ul>

<p>Those times are expressed in ticks of 1/100th of a second, also called “user
jiffies”. There are <code class="highlighter-rouge">USER_HZ</code> <em>“jiffies”</em> per second, and on x86 systems,
<code class="highlighter-rouge">USER_HZ</code> is 100. Historically, this mapped exactly to the number of scheduler
“ticks” per second, but higher frequency scheduling and
<a href="https://lwn.net/Articles/549580/">tickless kernels</a> have made the number of
ticks irrelevant.</p>

<h4 id="block-io-metrics">Block I/O metrics</h4>

<p>Block I/O is accounted in the <code class="highlighter-rouge">blkio</code> controller.
Different metrics are scattered across different files. While you can
find in-depth details in the <a href="https://www.kernel.org/doc/Documentation/cgroup-v1/blkio-controller.txt">blkio-controller</a>
file in the kernel documentation, here is a short list of the most
relevant ones:</p>

<table>
  <thead>
    <tr>
      <th>Metric</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>blkio.sectors</strong></td>
      <td>Contains the number of 512-bytes sectors read and written by the processes member of the cgroup, device by device. Reads and writes are merged in a single counter.</td>
    </tr>
    <tr>
      <td><strong>blkio.io_service_bytes</strong></td>
      <td>Indicates the number of bytes read and written by the cgroup. It has 4 counters per device, because for each device, it differentiates between synchronous vs. asynchronous I/O, and reads vs. writes.</td>
    </tr>
    <tr>
      <td><strong>blkio.io_serviced</strong></td>
      <td>The number of I/O operations performed, regardless of their size. It also has 4 counters per device.</td>
    </tr>
    <tr>
      <td><strong>blkio.io_queued</strong></td>
      <td>Indicates the number of I/O operations currently queued for this cgroup. In other words, if the cgroup isn’t doing any I/O, this is zero. The opposite is not true. In other words, if there is no I/O queued, it does not mean that the cgroup is idle (I/O-wise). It could be doing purely synchronous reads on an otherwise quiescent device, which can therefore handle them immediately, without queuing. Also, while it is helpful to figure out which cgroup is putting stress on the I/O subsystem, keep in mind that it is a relative quantity. Even if a process group does not perform more I/O, its queue size can increase just because the device load increases because of other devices.</td>
    </tr>
  </tbody>
</table>

<h3 id="network-metrics">Network metrics</h3>

<p>Network metrics are not exposed directly by control groups. There is a
good explanation for that: network interfaces exist within the context
of <em>network namespaces</em>. The kernel could probably accumulate metrics
about packets and bytes sent and received by a group of processes, but
those metrics wouldn’t be very useful. You want per-interface metrics
(because traffic happening on the local <code class="highlighter-rouge">lo</code>
interface doesn’t really count). But since processes in a single cgroup
can belong to multiple network namespaces, those metrics would be harder
to interpret: multiple network namespaces means multiple <code class="highlighter-rouge">lo</code>
interfaces, potentially multiple <code class="highlighter-rouge">eth0</code>
interfaces, etc.; so this is why there is no easy way to gather network
metrics with control groups.</p>

<p>Instead we can gather network metrics from other sources:</p>

<h4 id="iptables">IPtables</h4>

<p>IPtables (or rather, the netfilter framework for which iptables is just
an interface) can do some serious accounting.</p>

<p>For instance, you can setup a rule to account for the outbound HTTP
traffic on a web server:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> iptables <span class="nt">-I</span> OUTPUT <span class="nt">-p</span> tcp <span class="nt">--sport</span> 80
</code></pre></div></div>

<p>There is no <code class="highlighter-rouge">-j</code> or <code class="highlighter-rouge">-g</code> flag,
so the rule just counts matched packets and goes to the following
rule.</p>

<p>Later, you can check the values of the counters, with:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> iptables <span class="nt">-nxvL</span> OUTPUT
</code></pre></div></div>

<p>Technically, <code class="highlighter-rouge">-n</code> is not required, but it
prevents iptables from doing DNS reverse lookups, which are probably
useless in this scenario.</p>

<p>Counters include packets and bytes. If you want to setup metrics for
container traffic like this, you could execute a <code class="highlighter-rouge">for</code>
loop to add two <code class="highlighter-rouge">iptables</code> rules per
container IP address (one in each direction), in the <code class="highlighter-rouge">FORWARD</code>
chain. This only meters traffic going through the NAT
layer; you also need to add traffic going through the userland
proxy.</p>

<p>Then, you need to check those counters on a regular basis. If you
happen to use <code class="highlighter-rouge">collectd</code>, there is a <a href="https://collectd.org/wiki/index.php/Table_of_Plugins">nice plugin</a>
to automate iptables counters collection.</p>

<h4 id="interface-level-counters">Interface-level counters</h4>

<p>Since each container has a virtual Ethernet interface, you might want to check
directly the TX and RX counters of this interface. Each container is associated
to a virtual Ethernet interface in your host, with a name like <code class="highlighter-rouge">vethKk8Zqi</code>.
Figuring out which interface corresponds to which container is, unfortunately,
difficult.</p>

<p>But for now, the best way is to check the metrics <em>from within the
containers</em>. To accomplish this, you can run an executable from the host
environment within the network namespace of a container using <strong>ip-netns
magic</strong>.</p>

<p>The <code class="highlighter-rouge">ip-netns exec</code> command allows you to execute any
program (present in the host system) within any network namespace
visible to the current process. This means that your host can
 enter the network namespace of your containers, but your containers
can’t access the host or other peer containers.
Containers can interact with their sub-containers, though.</p>

<p>The exact format of the command is:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> ip netns <span class="nb">exec</span> &lt;nsname&gt; &lt;command...&gt;
</code></pre></div></div>

<p>For example:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> ip netns <span class="nb">exec </span>mycontainer netstat <span class="nt">-i</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ip netns</code> finds the “mycontainer” container by
using namespaces pseudo-files. Each process belongs to one network
namespace, one PID namespace, one <code class="highlighter-rouge">mnt</code> namespace,
etc., and those namespaces are materialized under
<code class="highlighter-rouge">/proc/&lt;pid&gt;/ns/</code>. For example, the network
namespace of PID 42 is materialized by the pseudo-file
<code class="highlighter-rouge">/proc/42/ns/net</code>.</p>

<p>When you run <code class="highlighter-rouge">ip netns exec mycontainer ...</code>, it
expects <code class="highlighter-rouge">/var/run/netns/mycontainer</code> to be one of
those pseudo-files. (Symlinks are accepted.)</p>

<p>In other words, to execute a command within the network namespace of a
container, we need to:</p>

<ul>
  <li>Find out the PID of any process within the container that we want to investigate;</li>
  <li>Create a symlink from <code class="highlighter-rouge">/var/run/netns/&lt;somename&gt;</code> to <code class="highlighter-rouge">/proc/&lt;thepid&gt;/ns/net</code></li>
  <li>Execute <code class="highlighter-rouge">ip netns exec &lt;somename&gt; ....</code></li>
</ul>

<p>Review <a href="#enumerate-cgroups">Enumerate Cgroups</a> for how to find
the cgroup of an in-container process whose network usage you want to measure.
From there, you can examine the pseudo-file named
<code class="highlighter-rouge">tasks</code>, which contains all the PIDs in the
cgroup (and thus, in the container). Pick any one of the PIDs.</p>

<p>Putting everything together, if the “short ID” of a container is held in
the environment variable <code class="highlighter-rouge">$CID</code>, then you can do this:</p>

<div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gp">$</span> <span class="nv">TASKS</span><span class="o">=</span>/sys/fs/cgroup/devices/docker/<span class="nv">$CID</span><span class="k">*</span>/tasks
<span class="gp">$</span> <span class="nv">PID</span><span class="o">=</span><span class="k">$(</span>head <span class="nt">-n</span> 1 <span class="nv">$TASKS</span><span class="k">)</span>
<span class="gp">$</span> mkdir <span class="nt">-p</span> /var/run/netns
<span class="gp">$</span> ln <span class="nt">-sf</span> /proc/<span class="nv">$PID</span>/ns/net /var/run/netns/<span class="nv">$CID</span>
<span class="gp">$</span> ip netns <span class="nb">exec</span> <span class="nv">$CID</span> netstat <span class="nt">-i</span>
</code></pre></div></div>

<h2 id="tips-for-high-performance-metric-collection">Tips for high-performance metric collection</h2>

<p>Running a new process each time you want to update metrics is
(relatively) expensive. If you want to collect metrics at high
resolutions, and/or over a large number of containers (think 1000
containers on a single host), you do not want to fork a new process each
time.</p>

<p>Here is how to collect metrics from a single process. You need to
write your metric collector in C (or any language that lets you do
low-level system calls). You need to use a special system call,
<code class="highlighter-rouge">setns()</code>, which lets the current process enter any
arbitrary namespace. It requires, however, an open file descriptor to
the namespace pseudo-file (remember: that’s the pseudo-file in
<code class="highlighter-rouge">/proc/&lt;pid&gt;/ns/net</code>).</p>

<p>However, there is a catch: you must not keep this file descriptor open.
If you do, when the last process of the control group exits, the
namespace is not destroyed, and its network resources (like the
virtual interface of the container) stays around forever (or until
you close that file descriptor).</p>

<p>The right approach would be to keep track of the first PID of each
container, and re-open the namespace pseudo-file each time.</p>

<h2 id="collect-metrics-when-a-container-exits">Collect metrics when a container exits</h2>

<p>Sometimes, you do not care about real time metric collection, but when a
container exits, you want to know how much CPU, memory, etc. it has
used.</p>

<p>Docker makes this difficult because it relies on <code class="highlighter-rouge">lxc-start</code>, which carefully
cleans up after itself. It is usually easier to collect metrics at regular
intervals, and this is the way the <code class="highlighter-rouge">collectd</code> LXC plugin works.</p>

<p>But, if you’d still like to gather the stats when a container stops,
here is how:</p>

<p>For each container, start a collection process, and move it to the
control groups that you want to monitor by writing its PID to the tasks
file of the cgroup. The collection process should periodically re-read
the tasks file to check if it’s the last process of the control group.
(If you also want to collect network statistics as explained in the
previous section, you should also move the process to the appropriate
network namespace.)</p>

<p>When the container exits, <code class="highlighter-rouge">lxc-start</code> attempts to
delete the control groups. It fails, since the control group is
still in use; but that’s fine. Your process should now detect that it is
the only one remaining in the group. Now is the right time to collect
all the metrics you need!</p>

<p>Finally, your process should move itself back to the root control group,
and remove the container control group. To remove a control group, just
<code class="highlighter-rouge">rmdir</code> its directory. It’s counter-intuitive to
<code class="highlighter-rouge">rmdir</code> a directory as it still contains files; but
remember that this is a pseudo-filesystem, so usual rules don’t apply.
After the cleanup is done, the collection process can exit safely.</p>
<span class="glyphicon glyphicon-tags" style="padding-right: 10px"></span><span style="vertical-align: 2px"><a href="/search/?q=docker">docker</a>, <a href="/search/?q=metrics">metrics</a>, <a href="/search/?q=CPU">CPU</a>, <a href="/search/?q=memory">memory</a>, <a href="/search/?q=disk">disk</a>, <a href="/search/?q=IO">IO</a>, <a href="/search/?q=run">run</a>, <a href="/search/?q=runtime">runtime</a>, <a href="/search/?q=stats">stats</a></span><div class="ratings-div"><div id="pd_rating_holder_8453675"></div></div></section>
                    </main>
                    <nav class="col-nav">
                        <div id="sidebar-nav" class="sidebar hidden-sm hidden-xs">
                            <div id="navbar" class="nav-sidebar">
                                <ul class="nav hidden-md hidden-lg"></ul>
                                <ul class="nav" id="jsTOCLeftNav"></ul>
                            </div>
                        </div>
                    </nav>
                    <div class="col-toc">
                        <div class="sidebar hidden-xs hidden-sm">
                            <div class="toc-nav">
                                <div class="feedback-links">
                                    <ul><li><a href="https://github.com/docker/docker.github.io/edit/master/config/containers/runmetrics.md"><i class="fa fa-pencil-square-o" aria-hidden="true"></i> Edit this page</a></li><li><a href="https://github.com/docker/docker.github.io/issues/new?body=File: [config/containers/runmetrics.md](https://docs.docker.com/config/containers/runmetrics/)" class="nomunge"><i class="fa fa-check" aria-hidden="true"></i> Request docs changes</a></li>
                                        <li><div class="toggle-mode">
  <div class="icon">
      <i class="fa fa-sun-o" aria-hidden="true"></i>
  </div>
  <div class="toggle-switch">
      <label class="switch">
          <input type="checkbox" id="switch-style">
          <span class="slider round"></span>
      </label>
  </div>
  <div class="icon">
      <i class="fa fa-moon-o" aria-hidden="true"></i>
  </div>
</div>
</li>
                                    </ul>
                                </div><div id="side-toc-title">On this page:</div>
<ul id="my_toc" class="inline_toc">
  <li><a href="#docker-stats" class="nomunge">Docker stats</a></li>
  <li><a href="#control-groups" class="nomunge">Control groups</a>
    <ul>
      <li><a href="#enumerate-cgroups" class="nomunge">Enumerate cgroups</a></li>
      <li><a href="#changing-cgroup-version" class="nomunge">Changing cgroup version</a></li>
      <li><a href="#running-docker-on-cgroup-v2" class="nomunge">Running Docker on cgroup v2</a></li>
      <li><a href="#find-the-cgroup-for-a-given-container" class="nomunge">Find the cgroup for a given container</a></li>
      <li><a href="#metrics-from-cgroups-memory-cpu-block-io" class="nomunge">Metrics from cgroups: memory, CPU, block I/O</a></li>
      <li><a href="#cpu-metrics-cpuacctstat" class="nomunge">CPU metrics: cpuacct.stat</a></li>
      <li><a href="#network-metrics" class="nomunge">Network metrics</a></li>
    </ul>
  </li>
  <li><a href="#tips-for-high-performance-metric-collection" class="nomunge">Tips for high-performance metric collection</a></li>
  <li><a href="#collect-metrics-when-a-container-exits" class="nomunge">Collect metrics when a container exits</a></li>
</ul>

</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <footer class="footer">
          
    <div class="container">
        <div class="top_footer">
            <div class="row">
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/why-docker">Why Docker?</a></b></li>
                        <li><a href="https://www.docker.com/what-container">What is a Container?</a></li>
                        <li><a href="https://docker.events.cube365.net/dockercon/">DockerCon</a></li>
                        <li><b><a href="https://www.docker.com/products/overview">Products</a></b></li>
                        <li><a href="https://www.docker.com/products/docker-desktop">Docker Desktop</a></li>
                        <li><a href="https://www.docker.com/products/docker-hub">Docker Hub</a></li>
                        <li><a href="https://www.docker.com/roadmap">Docker Product Roadmap</a></li>
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Features</a></b></li>
                        <li><a href="https://www.docker.com/products/container-runtime">Container Runtime</a></li>
                        <li><a href="https://www.docker.com/products/developer-tools">Developer Tools</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Developers</a></b></li>
                        <li><a href="https://www.docker.com/use-cases">Use Cases</a></li>
                        <li><a href="https://www.docker.com/docker-community">Community</a></li>
                        <li><a href="https://www.docker.com/open-source">Open Source</a></li>
                        <li><a href="https://www.docker.com/community/docker-captains">Docker Captains</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/products/docker-desktop">Pricing</a></b></li>
                        <li><a href="https://www.docker.com/pricing/faq">FAQs</a></li>
                        <li><a href="https://www.docker.com/partners/programs">Docker Verified Publisher Program</a></li>
                    </ul>
                </div>
                <div class="col-xs-12 col-sm-3 col-md-3">
                    <ul class="footer_links">
                        <li><b><a href="https://www.docker.com/company" target="_blank" rel="noopener">Company</a></b></li>
                        <li><a href="https://www.docker.com/company">About Us</a></li>
                        <li><a href="https://www.docker.com/blog/" target="_blank" rel="noopener">Blog</a></li>
                        <li><a href="https://www.docker.com/customers">Customers</a></li>
                        <li><a href="https://www.docker.com/partners">Partners</a></li>
                        <li><a href="https://www.docker.com/company/newsroom">Newsroom</a></li>
                        <li><a href="https://www.docker.com/careers">Careers</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact Us</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-nav">
                <nav class="footer_sub_nav">
                    <ul class="menu">
                        <li><a href="http://status.docker.com/">Status</a></li>
                        <li><a href="https://www.docker.com/legal">Legal</a></li>
                        <li><a href="https://www.docker.com/company/contact">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </div>
        <div class="bottom_footer">
            <div class="footer-copyright col-xs-12 col-md-8">
                <p class="copyright">
                    Copyright &copy; 2013-2021 Docker Inc. All rights reserved. </p>
            </div>
            <div class="footer_social_nav">
                <ul class="nav-social">
                    <li class="fa fa-twitter"><a href="http://twitter.com/docker">Twitter</a></li>
                    <li class="fa fa-youtube"><a href="http://www.youtube.com/user/dockerrun">Youtube</a></li>
                    <li class="fa fa-github"><a href="https://github.com/docker">GitHub</a></li>
                    <li class="fa fa-linkedin"><a href="https://www.linkedin.com/company/docker">Linkedin</a></li>
                    <li class="fa fa-facebook"><a href="https://www.facebook.com/docker.run">Facebook</a></li>
                    <li class="fa fa-slideshare"><a href="https://www.slideshare.net/docker">Slideshare</a></li>
                    <li class="fa fa-reddit"><a href="https://www.reddit.com/r/docker">Reddit</a></li>
                </ul>
            </div>
        </div>
    </div>

    </footer>
    <script>const pageURL = "/config/containers/runmetrics/";</script><script>
    let PDRTJS_settings_8453675 = {
        "id": "8453675",
        "unique_id": "config/containers/runmetrics.md",
        "title": "Runtime metrics",
        "font_family": "Open Sans, sans serif",
        "font_color": "b9c2cc",
        "font_align": "center",
        "permalink": "https://github.com/docker/docker.github.io/blob/master/config/containers/runmetrics.md"
    };
    (function (d, c, j) {
        if (!document.getElementById(j)) {
            let pd=d.createElement(c),s;pd.id=j;pd.src='https://polldaddy.com/js/rating/rating.js';s=document.getElementsByTagName(c)[0];s.parentNode.insertBefore(pd, s);
        }
    }(document, 'script', 'pd-rating-js'));
</script></body>
</html>
